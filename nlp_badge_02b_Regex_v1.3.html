<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-09-12">

<title>Badge 2b Regular Expressions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="nlp_badge_02b_Regex_v1.3_files/libs/clipboard/clipboard.min.js"></script>
<script src="nlp_badge_02b_Regex_v1.3_files/libs/quarto-html/quarto.js"></script>
<script src="nlp_badge_02b_Regex_v1.3_files/libs/quarto-html/popper.min.js"></script>
<script src="nlp_badge_02b_Regex_v1.3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="nlp_badge_02b_Regex_v1.3_files/libs/quarto-html/anchor.min.js"></script>
<link href="nlp_badge_02b_Regex_v1.3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="nlp_badge_02b_Regex_v1.3_files/libs/quarto-html/quarto-syntax-highlighting-3a01e2046221230fdceeea94b1ec5d67.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="nlp_badge_02b_Regex_v1.3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="nlp_badge_02b_Regex_v1.3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="nlp_badge_02b_Regex_v1.3_files/libs/bootstrap/bootstrap-34745567add538a638dde46bc8a747e1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Badge 2b Regular Expressions</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 12, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="regular-expressions" class="level1">
<h1>Regular Expressions</h1>
<p>In this notebook we will look at Regular Expression in R.</p>
<section id="what-are-regular-expressions" class="level2">
<h2 class="anchored" data-anchor-id="what-are-regular-expressions">What are Regular Expressions?</h2>
<p>Regular expressions are a concise and flexible tool for describing patterns in strings. We are going to show examples using <em>stringr</em> functionality and the <em>gsub</em> function.</p>
<p>We covered some basic pattern matching in Badge 2-1 Stings using <em>str_extract</em>, <em>str_detect</em>, <em>str_replace</em> (recap of these below)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>mystring <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'We love NLP! Do you LOVE NLP?'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># outputs the characters where the word is found - only outputs the first one str_locate(mystring, "NLP")</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Replaces the first word with the last</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace</span>(mystring, <span class="st">"We"</span>, <span class="st">"Cats"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Cats love NLP! Do you LOVE NLP?"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Detects if the string is present</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(mystring, <span class="st">"love"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "love"</code></pre>
</div>
</div>
<p>Regular expressions can be complex use a lot of punctuation characters. It can seem overwhelming and hard to understand. It takes time and practice to learn regular expressions … and patience.</p>
<p>Let’s recap on some of the things we learned in the slides for this badge.</p>
</section>
<section id="finding-patterns" class="level2">
<h2 class="anchored" data-anchor-id="finding-patterns">Finding Patterns</h2>
<p><strong>Anchors:</strong></p>
<p>By default, regular expressions match any part of a string. It can be useful to anchor the regular expression to match from the start or end of the string:</p>
<p><code>^</code> matches the start of string. <code>$</code> matches the end of the string.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>mystring <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'We love cats! We are not so keen on spiders.'</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#detects if We followed by at least one space is present at the start of our string.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(mystring, <span class="st">"^We</span><span class="sc">\\</span><span class="st">s+"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "We "</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>mystring <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'We'</span>, <span class="st">'Love'</span>, <span class="st">'Cats'</span>, <span class="st">'not'</span>, <span class="st">'keen'</span>, <span class="st">'on'</span>, <span class="st">'spiders'</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#detects where s is at the end of our string.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(mystring, <span class="st">"s$"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NA  NA  "s" NA  NA  NA  "s"</code></pre>
</div>
</div>
<p>Quantifiers control how many times a pattern can match:</p>
<ul>
<li><p><code>?</code> makes a pattern optional (i.e.&nbsp;it matches 0 or 1 times)</p></li>
<li><p><code>+</code> lets a pattern repeat (i.e.&nbsp;it matches at least once)</p></li>
<li><p><code>*</code> lets a pattern be optional or repeat (i.e.&nbsp;it matches any number of times, including 0).</p></li>
<li><p><code>{3,7}</code> lets a pattern repeat between 3 and 7 times (you can change it to any other two numbers you’d like)</p></li>
</ul>
<p>Character classes are defined by <code>[ ]</code> and let you match a set of characters, e.g., <code>[Mm]</code> matches “M”, “m”.</p>
<p>You can also invert the match by starting with <code>^</code>: <code>[\^Mm]</code> matches anything except “M”, “m”, [A-Z] matches all upper case characters</p>
</section>
<section id="replacing-many-occurrences-of-patterns-gsub" class="level2">
<h2 class="anchored" data-anchor-id="replacing-many-occurrences-of-patterns-gsub">Replacing many occurrences of patterns (gsub)</h2>
<p>Above we just thought about finding things in strings.</p>
<p>We will use <em>gsub</em> to find extra spaces in our sentence. The function <em>sub</em> (like str_replace) can be used but this only finds the first match, but a more powerful <em>gsub</em> finds all matches in a string.( it stands for “a global sub”)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>my_sentences <span class="ot">&lt;-</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Hello,  how are you today?     I am looking forward to fun with NLP. Are you? Hello to you to, yes I am ."</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(my_sentences)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Hello,  how are you today?     I am looking forward to fun with NLP. Are you? Hello to you to, yes I am ."</code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Both sentences have extra spaces. Lets look at how we can fix that by finding multiple spaces and replacing with a single space.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>my_sentences_updated <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">'</span><span class="sc">\\</span><span class="st">s+'</span>, <span class="st">' '</span>, my_sentences)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(my_sentences_updated)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Hello, how are you today? I am looking forward to fun with NLP. Are you? Hello to you to, yes I am ."</code></pre>
</div>
</div>
<p>OK, brace brace, we will do something simple: identify and clean-up multiple space characters (replace them with just one space character). But as we do it… we will learn a lot of stuff about escaping.</p>
</section>
<section id="escaping-special-meanings-of-characters-with-a" class="level2">
<h2 class="anchored" data-anchor-id="escaping-special-meanings-of-characters-with-a">ESCAPING special meanings of characters with a <code>\</code></h2>
<p><strong>example: recognising a sentence:</strong></p>
<p>Example of how to capture patterns in brackets <code>( )</code> to replace only parts of strings.</p>
<p>Let’s imagine we wanted to fix the extra space before the period in the last sentence.</p>
<p>In regex you can use brackets <code>( )</code> to capture patterns and then reference these to match and replace only part of the string.</p>
<p>In the example below:</p>
<ul>
<li><p><code>.</code> - matches any character</p></li>
<li><p><code>*</code> - expects that match zero or more times</p></li>
<li><p><code>\s</code> - means a ‘space’ character So <code>.*\s*</code> means match any character until it matches a zero or more spaces.</p></li>
<li><p><code>$</code> - matches end of string (not an actual dollar symbol <code>$</code>, because <code>$</code> has a special meaning like <code>.</code> or <code>*</code>., you will read about it below)</p></li>
<li><p><code>\.</code> - matches the literal fullstop symbol <code>.</code> (in opposite to the ‘regex meaning of fullstop’ which would be ‘any character’. Just like with $ above)</p></li>
</ul>
<p><strong>In other words we want something like <code>.*\s*\$</code></strong></p>
<p><strong>Explanation of “escaping”:</strong></p>
<p>We use <code>\</code> symbol before a character in a regex to ‘escape’ that character’s usual meaning. This might make it special if usually it is normal: <code>s</code> normally just means a letter s, but <code>\s</code> means ‘a space’. And if it usually is special, it will become normal, e.g.&nbsp;fullstop <code>.</code> usually has a special meaning of ‘any character’, but <code>\.</code> simply means a fullstop, a dot.</p>
<p>So…</p>
<p><code>.*\s*\.$</code> - matches a sequence of 0 or more characters, followed by zero or more spaces, that then ends with a literal fullstop ‘.’ and then reaches an end of string. So basically… ‘the last sentence’.</p>
<p>But when we try to use it in our code things go wrong. That’s because we are missing one more step.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sentence <span class="ot">&lt;-</span> <span class="st">"some sentence."</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">#str_extract(sentence, ".*\s*\.\$") </span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># OH NOT WHEN WE RUN THIS WE WILL SEE AN ERROR! it will look a bit like this:</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Error: '\s' is an unrecognised escape in character string starting ""`.*\s"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>OH NO! What’s going on? 🔥🔥🔥</p>
<p><strong>The answer is… DOUBLE ESCAPING?</strong></p>
<p>Essentially you need to escape things twice, because the regex you wrote is INTERPRETED TWICE - first time by the R language, and then again by the Regex language. So, for the same of R you will need to escape each <code>\</code> AGAIN so that it is allowed to be special itself. Do not panic, it will start coming naturally to you. In short each <code>\</code> will become <code>\\</code> so that R allows our <code>\</code> to be special.</p>
<p><strong>Explanation of what happens in R when you escape string:</strong></p>
<p>You are writing your regex as a string in R. And strings in R also can have ‘special’ characters, like new line/enter (<code>\n</code>) or tab (<code>\t</code>) which R escapes with a <code>\</code> to distinguish them with actual letters <code>n</code> and <code>t</code>. So in R strings the symbol of <code>\</code> is very special and meaningful… hence we can also escape it, so actual use a slash <code>\</code>. See example below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># So before you run this code, try to imagine what will get shown on the screen?</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"bana</span><span class="sc">\n</span><span class="st">as are yellow, or</span><span class="sc">\t</span><span class="st"> brown</span><span class="sc">\\</span><span class="st">yellow "</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>bana
as are yellow, or    brown\yellow </code></pre>
</div>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># here we escaped one enter, one tab, and one \! Can you find where?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># notice that we used cat() above, because print will return the string, without INTERPRETTING IT.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"bana</span><span class="sc">\n</span><span class="st">as are yellow, or</span><span class="sc">\t</span><span class="st"> brown</span><span class="sc">\\</span><span class="st">yellow "</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "bana\nas are yellow, or\t brown\\yellow "</code></pre>
</div>
</div>
<p><strong>Conclusion: either write of your regex in a simple form, then add slash &nbsp;before each slash &nbsp;or just use double slash \ from the beginning</strong></p>
<p>Let’s make the final step: to double-escape our <code>.*\s*$</code> it will become something like<code>.*\\s$</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># here we show you a sequence of how you are likely to build your regex:</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">".*</span><span class="sc">\\</span><span class="st">s*.$"</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(<span class="st">"words."</span>, pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "words."</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(<span class="st">"a few words ."</span>, pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a few words ."</code></pre>
</div>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(<span class="st">"many words      ."</span>, pattern) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "many words      ."</code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># notice the same pattern can recognise a number of different sentences</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>But why is this useful? When you find some patterns you wish to extract from strings. Keep reading.</p>
</section>
<section id="parts-of-a-pattern-brackets" class="level2">
<h2 class="anchored" data-anchor-id="parts-of-a-pattern-brackets">Parts of a pattern (brackets)</h2>
<p><strong>Why are brackets useful?</strong></p>
<p>Because currently we are just told “yes, this whole string matches the pattern”, but we might want to extract just parts of the pattern (e.g.. just the first 3 characters of a post-code)</p>
<p>Also… you already realised that complicated Regex can be rather hard to read and decipher. Brackets, which solve a number of our problems in one go.</p>
<p><strong>Organising code is always useful</strong></p>
<p>The function of the brackets is to group and organise the matches which are parts of your regex. In our example above we had four parts/groups in our regex: characters, spaces, fullstop and end of the string. With brackets we can start thinking about them as these groups of recognised characters, and each group is assigned a number in the order they appear.</p>
<p>So if we break down <code>.*\s*.$</code> into groups as detailed above, which will look like this <code>(.*)(\s*)(.)($)</code> then we can say that e.g <code>(.*)</code> is group 1, <code>($)</code> is group 4. Below you will see how we can access those groups individually - group one will be referred to as <code>\1</code>, group 2 as <code>\2</code> etc..</p>
<p><strong>Why is this useful? Because you can recognise patters, and replace them with a ‘remix’ of that pattern</strong>.</p>
</section>
<section id="using-groups-to-achieve-complicated-and-useful-things" class="level2">
<h2 class="anchored" data-anchor-id="using-groups-to-achieve-complicated-and-useful-things">Using groups to achieve complicated and useful things:</h2>
<p>For example: replace all instances of a word with another word, but only if it is at the end of a sentence, or only if it is in between some other words. Or change a format of a phone number or address.</p>
<p><strong>Here’s an example:</strong></p>
<p>you’d like the replace each instance of phone numbers starting with a 0044 like 00441234567 into a format (UK) 123-4567. What you need to do is first describe the long number as groups of digits <code>(0044)(\d{3})(\d{4})</code> - meaning group of two zeros and two fours, followed by three digits and then 4 digits. So we separate our match into 3 groups.</p>
<p>And then you’d like to replace the first group with (UK) and put some spaces and dashes between the other two groups.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>old_phone_number <span class="ot">&lt;-</span> <span class="st">'00441234567 or 00445555555 and some non-matching ones: 0044 0044-555-5555 0048123456 0441234567 004412X4567 +445555555'</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">"(0044)(</span><span class="sc">\\</span><span class="st">d{3})(</span><span class="sc">\\</span><span class="st">d{4})"</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>replace_with_this <span class="ot">&lt;-</span> <span class="st">"(UK) </span><span class="sc">\\</span><span class="st">2-</span><span class="sc">\\</span><span class="st">3"</span> </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># what does it do? first string (UK) then space, second group, dash, third group</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co"># notice that because this is an 'output' pattern, brackets do not have a spacial meaning</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>new_phone_number <span class="ot">&lt;-</span> <span class="fu">gsub</span>(pattern, replace_with_this, old_phone_number)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(new_phone_number)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "(UK) 123-4567 or (UK) 555-5555 and some non-matching ones: 0044 0044-555-5555 0048123456 0441234567 004412X4567 +445555555"</code></pre>
</div>
</div>
<p><strong>Another example, removing spaces before the fullstops and other end of sentence characters:</strong></p>
<p>In the <strong>gsub</strong> command below we are telling <strong>gsub</strong> to keep only what was captured in the second bracket. Thus removing the extra space before the ‘.’</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">#use gsub to remove the space before the period at the end.</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>my_sentences <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Hello,  how    are you   today   ?"</span>,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"I am looking.   forward to fun with NLP   ."</span>,</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Are you ok?"</span>,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Are you ok ?"</span>,</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Are you ok  ?"</span>,</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Hello to you too, yes I am   !"</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>my_sentences_updated <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">'(</span><span class="sc">\\</span><span class="st">s*)([</span><span class="sc">\\</span><span class="st">.!?])$'</span>, <span class="st">'</span><span class="sc">\\</span><span class="st">2'</span>, my_sentences)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="co"># recognise a group of spaces, then one of the symbols ?!. and then end of string</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co"># then replace them with just the symbol ?!. (delete the spaces which were group \\1)</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(my_sentences_updated)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Hello,  how    are you   today?"         
[2] "I am looking.   forward to fun with NLP."
[3] "Are you ok?"                             
[4] "Are you ok?"                             
[5] "Are you ok?"                             
[6] "Hello to you too, yes I am!"             </code></pre>
</div>
</div>
<p>In the previous coding exercise we used other functions like <strong>str_extract</strong>, <strong>str_replace</strong>. These can also be used in conjunction with regular expressions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>my_sentence <span class="ot">&lt;-</span> <span class="st">"Hello, how are you today? I am looking forward to fun with NLP. What time does it start? It starts at 1pm, do you want to do lunch at 12pm?"</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract any number of digits immediately followed by 'pm'</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>time1 <span class="ot">&lt;-</span> <span class="fu">str_extract</span>(my_sentence, <span class="st">"</span><span class="sc">\\</span><span class="st">d+pm"</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(time1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1pm"</code></pre>
</div>
</div>
<p><strong>Another example: Swap first names and surnames</strong></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>names_old <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Jill Mathews"</span>,</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">"Prianka O'Brian"</span>,</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>               <span class="st">"Pim Ng"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>names_new <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">'(.*) (.*)'</span>, <span class="st">'</span><span class="sc">\\</span><span class="st">2 </span><span class="sc">\\</span><span class="st">1'</span>, names_old)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co"># describe with your own words what happens here!</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co"># '(.*)' means that we capture any character zero or more times</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># So, group \\1 is the first name, group \\2 is the surname</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co"># relies on have two names, or hyphenated surnames etc.</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(names_new)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Mathews Jill"    "O'Brian Prianka" "Ng Pim"         </code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># now with a comma</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>names_new2 <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">'(.*) (.*)'</span>, <span class="st">'</span><span class="sc">\\</span><span class="st">2, </span><span class="sc">\\</span><span class="st">1'</span>, names_old)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(names_new2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Mathews, Jill"    "O'Brian, Prianka" "Ng, Pim"         </code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_pre.Rmd">hint for task 00</a></p>
</section>
<section id="activity-1" class="level2">
<h2 class="anchored" data-anchor-id="activity-1">Activity 1:</h2>
<ol type="1">
<li>Can you write a regular expression which capture all places where time is mentioned in my_sentence? For simplicity you could assume time is always pm. (would <code>str_extract_all</code> be a good tool to use?)</li>
</ol>
<p>for future: in your r console on he bottom of the screen type this: <code>?str_extract_all</code> it will show you the documentation of a new useful function which expands on <em>str_extract_all</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>my_sentence <span class="ot">&lt;-</span> <span class="st">"Hello, how are you today? I am looking forward to fun with NLP. What time does it start? It starts at 1pm, do you want to do lunch at 12pm?"</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co"># write your code here</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(my_sentence, <span class="st">"</span><span class="sc">\\</span><span class="st">d+pm"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "1pm"  "12pm"</code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_1.Rmd">hint for task 01</a></p>
<ol start="2" type="1">
<li>Now change the my_sentence string, so that the class starts at 1:30pm (instead of 1pm) with str_replace? (no need to use regex here yet, unless you want to). Put the result back into the variable my_sentence.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>my_sentence <span class="ot">&lt;-</span> <span class="st">"Hello, how are you today? I am looking forward to fun with NLP. What time does it start? It starts at 1pm, do you want to do lunch at 12pm?"</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"># write your code here</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>new_sentence <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(my_sentence, <span class="st">"1pm"</span>, <span class="st">"1:30pm"</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>new_sentence</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Hello, how are you today? I am looking forward to fun with NLP. What time does it start? It starts at 1:30pm, do you want to do lunch at 12pm?"</code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_2.Rmd">hint for task 02</a></p>
<ol start="3" type="1">
<li>Let’s come back to using regex: You know how to capture time on the simple 1pm format. But how would you capture time in this new format e.g.. 1:30pm? And then how would you write a regex which could capture time in EITHER one of the formats? 1pm and 1:30pm? Regex has an OR operator for which you use the ‘pipe symbol’ which looks like this <code>|</code> so you can say <code>a|b</code> meaning <code>a</code> or <code>b</code></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>my_sentence <span class="ot">&lt;-</span> <span class="st">"Hello, how are you today? I am looking forward to fun with NLP. What time does it start? It starts at 1:30pm, do you want to do lunch at 12pm?"</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co"># write your code here</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>time_pat <span class="ot">&lt;-</span> <span class="st">"(</span><span class="sc">\\</span><span class="st">d+pm)|(</span><span class="sc">\\</span><span class="st">d+:</span><span class="sc">\\</span><span class="st">d+pm)"</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(my_sentence, time_pat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "1:30pm" "12pm"  </code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_3.Rmd">hint for task 03</a></p>
</section>
<section id="activity-2" class="level2">
<h2 class="anchored" data-anchor-id="activity-2">Activity 2:</h2>
<p>Patterns extraction: Next imagine we want to capture all the birthdays in a piece of text. For simplicity let’s assume birthdays are always in a format like 23-03-1987 or 30-06-2002. Below you are given some text to test your Regex on.</p>
<p>To keep it simple, for now let’s say that dates can be any combination of two-two-four digits (the dates do not need to be actual real dates), so 31-02-2000 is fine, and so is 45-67-8901 and 00-00-0000</p>
<ol type="1">
<li>Can you write a regex to extract the one birthday in the sentence below?</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>sentence_with_birthday <span class="ot">&lt;-</span> <span class="st">"Natasha Smyth was born on 30-01-1999 and loves NLP."</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"># write your code here</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(sentence_with_birthday, <span class="st">"</span><span class="sc">\\</span><span class="st">d{2}-</span><span class="sc">\\</span><span class="st">d{2}-</span><span class="sc">\\</span><span class="st">d{4}"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "30-01-1999"</code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_4.Rmd">hint for task 04</a></p>
<ol start="5" type="1">
<li>What if there was more than one birthday in the string? Here you are given another sentence - add your own birthday at the end of it, and then write code which will extract all four birthdays using a regular expression.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>sentence_with_many_birthdays <span class="ot">&lt;-</span> <span class="st">"Natasha Smyth was born on 30-01-1999 and loves NLP. Her friend Pat was born on 02-01-2000 and their friend Kat was born on 13-11-1997. And your birthday is ...?"</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co"># write your code here</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(sentence_with_many_birthdays, <span class="st">"</span><span class="sc">\\</span><span class="st">d{2}-</span><span class="sc">\\</span><span class="st">d{2}-</span><span class="sc">\\</span><span class="st">d{4}"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "30-01-1999" "02-01-2000" "13-11-1997"</code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_5.Rmd">hint for task 05</a></p>
</section>
</section>
<section id="extra-task-for-the-curious-write-down-what-time-it-is.-do-not-spend-over-10-minutes-on-this-for-now." class="level1">
<h1>Extra task for the curious (write down what time it is. Do not spend over 10 minutes on this for now.)</h1>
<p>Given below string, identify in it all possible room numbers in the a hospital. You know that the room number always starts with a Letter for the floor (‘B’,‘F’,‘S’,‘T’) then a dot ‘.’, followed the number of the room on that floor which is a number made of 1,2 or 3 digits (e.g., 3,12,133) finally a letter which indicates if the room is used for Teaching (T), Admin (A), Research (R) or Patient-related tasks (P). So example room names could be: B.21R is a room 21 on basement floor used for research, S.111P is a room 111 on second floor used for seeing patients. Inappropriate room number would use other letters (or miss them) at the beginning or end, and would have no digits or more than 3 digits.</p>
<p>Try to first get the most simple cases to work, and only then engage with more difficult situations</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>string_with_some_rooms <span class="ot">&lt;-</span> <span class="st">"potential room names are: B-182P BF.243R A_23 A.1223 B-1 B.1 B.1X B.12P B.12 T.T T.T123 .12A 12A T.333T T.333A A.333A and that's all of them"</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co"># hint: before you start writing code, first decide by hand which of the above are correct room numbers following the above key? for example, would you agree that correct room names are "B.12P T.333T T.333A"</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co"># always make a change -&gt; run your code -&gt; see what is still missing -&gt; repeat</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co"># write your code here</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>roomRegrex <span class="ot">&lt;-</span> <span class="st">"([BFST]{1}</span><span class="sc">\\</span><span class="st">.)(</span><span class="sc">\\</span><span class="st">d{1,3})([TARP]{1})"</span> <span class="co"># NB need to escape the full-stop: \\.</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(string_with_some_rooms, roomRegrex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "F.243R" "B.12P"  "T.333T" "T.333A"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># this extract "F.243R" from "BF.243R", which we don't want...</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co"># read the 'Note for later' paragraph... use a Lookback to make sure there's a space beforehand</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co"># also use a Lookahead to ensure space afterwards</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>roomRegrex2 <span class="ot">&lt;-</span> <span class="st">"(?&lt;=</span><span class="sc">\\</span><span class="st">s)([BFST]{1}</span><span class="sc">\\</span><span class="st">.)(</span><span class="sc">\\</span><span class="st">d{1,3})([TARP]{1})(?=</span><span class="sc">\\</span><span class="st">s{1})"</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(string_with_some_rooms, roomRegrex2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "B.12P"  "T.333T" "T.333A"</code></pre>
</div>
</div>
<p><a href="./hints/hint_2b_6.Rmd">first hint for task 06 - how to think about this task</a></p>
<p><a href="./hints/hint_2b_7.Rmd">second hint for task 06 - how to start coding this task</a></p>
<section id="note-for-later" class="level2">
<h2 class="anchored" data-anchor-id="note-for-later">Note for later:</h2>
<p>At the end of the course come back to this badge. Regex is a huge and fascinating topic and there are lots of useful mechanisms for recognising complicated patters, or context around the words. While we will not show them all in this badge, you will likely at some point have to learn them by yourself.</p>
<p>Here’s one advanced example: For example, How would you find words that have a given symbol just before them, or after them, but without including that symbol in your find? For example if you want to find all numbers describing minutes in text (like 25mins, 10mins, 60mins) but you only want to grab those numbers (25,10,60) without the ‘mins’ part? You would use a “Lookahead” which checks for things AFTER what you care about: ‘\d+(?=mins)’ means one or more numbers followed by a string “mins”. The syntax of lookahead is (?=abc) which means that your match is followed by abc. There is also a look-back (?&lt;=abc) - do you see now how we’ve just scratched the surface?</p>
<p>We hope you will keep coming back to Regex, and keep discovering how fun it can be.</p>
<p><a href="./hints/hint_2b_8.Rmd">example of how you could fix some tricky room names from the task above</a></p>
</section>
</section>
<section id="reflection" class="level1">
<h1>Reflection:</h1>
<p>Now is a good moment to write down your self reflection: think of 3 STARS (things that you learned in this badge), and 1 WISH: a thing you wish you understood better. You might also thing of what would you do to fulfil your wish. Write them down.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion:</h1>
<p>Regular expressions take time and patience to learn and like most things in R there are different way to achieve the same thing.</p>
<p>We have used on a number of ways in this exercise to find and change strings in our data with regular expressions and R functions. Next week we will use these functions again when cleaning and reprocessing our data.</p>
</section>
<section id="further-reading" class="level1">
<h1>Further reading:</h1>
<p><a href="https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html#matching-multiple-characters">Stringr documentation is really worth a look if you’d like to understand how Regex works</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>